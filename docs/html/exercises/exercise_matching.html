
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Matching Exercise &#8212; Unifying Data Science</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="Matching-Exercise">
<h1>Matching Exercise<a class="headerlink" href="#Matching-Exercise" title="Permalink to this headline">¶</a></h1>
<p>In this exercise, we’ll be evaluating how getting a college degree impacts earnings in the US using matching.</p>
<div class="section" id="Matching-Packages:-Python-v.-R">
<h2>Matching Packages: Python v. R<a class="headerlink" href="#Matching-Packages:-Python-v.-R" title="Permalink to this headline">¶</a></h2>
<p>Just as the best tools for machine learning tend to be in Python since they’re developed by CS people (who prefer Python), most of the best tools for causal inference are implemented in R since innovation in causal inference tends to be lead by social scientists using R. As a result, the most well developed matching package is called <a class="reference external" href="https://kosukeimai.github.io/MatchIt/index.html">MatchIt</a>, and is only available in R (though you can always call it from Python using <code class="docutils literal notranslate"><span class="pre">rpy2</span></code>).</p>
<p>In the last year, though, a group of computer scientists and statisticians here at Duke have made some great advancements in matching (especially the computational side of things), and they recently released a set of matching packages in both R and Python that we’ll be using today. They have some great algorithms we’ll use today, but be aware these packages aren’t as mature, and aren’t general purpose packages yet. So if you ever get deep into matching, be aware you will probably still want to
make at least partial use of the R package <a class="reference external" href="https://kosukeimai.github.io/MatchIt/index.html">MatchIt</a>, as well as some other R packages for new innovative techniques (like <a class="reference external" href="https://projects.iq.harvard.edu/frontier/home">Matching Frontier estimation</a>), or <a class="reference external" href="https://almost-matching-exactly.github.io/AHB-R-package/">Adaptive Hyper-Box Matching</a>.</p>
</div>
<div class="section" id="Installing-dame-flame.">
<h2>Installing dame-flame.<a class="headerlink" href="#Installing-dame-flame." title="Permalink to this headline">¶</a></h2>
<p>For this lesson, begin by installing <code class="docutils literal notranslate"><span class="pre">dame-flame</span></code> with <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">dame-flame</span></code> (it’s not on conda yet).</p>
<p><a class="reference external" href="https://almost-matching-exactly.github.io/DAME-FLAME-Python-Package">DAME</a> is an algorithm that we can use for a version of course exact matching. The package only accepts a list of categorical variables, and then attempts to match pairs that match exactly on those variables. That means that if you want to match on, say, age, you have to break it up into categories (say, under 18, 18-29, 30-39, etc. etc.).</p>
<p>Of course, one cannot always find exact matches on all variables, so what DAME does is:</p>
<ol class="arabic simple">
<li><p>Find all observations that match on <em>all</em> matching variables.</p></li>
<li><p>Figure out which matching variable is least useful in predicting the outcome of interest <span class="math notranslate nohighlight">\(Y\)</span> and drops that, then tries to match the remaining observations on the narrowed set of matching variables.</p></li>
<li><p>This repeats until you run out of variables, all observations are matched, or you hit a stopping run (namely: quality of matches falls below a threshold).</p></li>
</ol>
<p>In addition, the lab has also created FLAME, which does the same thing, but employs some tricks to make it <em>massively</em> more computationally efficient, meaning it can be used on datasets with millions of observations (which most matching algorithms cannot). It’s a little less accurate, but an amazing contribution never the less.</p>
</div>
<div class="section" id="Data-Setup">
<h2>Data Setup<a class="headerlink" href="#Data-Setup" title="Permalink to this headline">¶</a></h2>
<p>To save you some time and let you focus on matching, I’ve <em>pre-cleaned</em> about one month worth of of data from the US Current Population Survey data we used for our <a class="reference external" href="exercises/exercises_regression_incomeineq.ipynb">gender discrimination analysis</a>. You can download the data <a class="reference external" href="https://github.com/nickeubank/MIDS_Data/blob/master/Current_Population_Survey/cps_for_matching.dta?raw=true%22">from here</a>, or read it directly with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cps</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_stata</span><span class="p">(</span>
    <span class="s2">&quot;https://github.com/nickeubank/MIDS_Data/blob/master&quot;</span>
    <span class="s2">&quot;/Current_Population_Survey/cps_for_matching.dta?raw=true&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Load the data and quickly familiarize yourself with its contents.</p>
</div>
<div class="section" id="Getting-To-Know-Your-Data">
<h2>Getting To Know Your Data<a class="headerlink" href="#Getting-To-Know-Your-Data" title="Permalink to this headline">¶</a></h2>
<p>Before you start matching, it is important to examine your data to ensure that matching is feasible (you have some overlap the the features of people in the treated and untreated groups), and also that there is a reason <em>to</em> match: either you’re unsure about some of the functional forms at play, or your have some imbalance between the two groups.</p>
<div class="section" id="Exercise-1">
<h3>Exercise 1<a class="headerlink" href="#Exercise-1" title="Permalink to this headline">¶</a></h3>
<p>Show the raw difference of <code class="docutils literal notranslate"><span class="pre">annual_earnings</span></code> between those with and without a college degree (<code class="docutils literal notranslate"><span class="pre">has_college</span></code>). Is the difference statistically significant?</p>
</div>
<div class="section" id="Exercise-2">
<h3>Exercise 2<a class="headerlink" href="#Exercise-2" title="Permalink to this headline">¶</a></h3>
<p>Next we can check for balance. Check the share of people in different racial groups who have college degrees. Are those differences statistically significant?</p>
<p>Does the distribution also look different across counties (I don’t need statistical significance for this)?</p>
<p>Does the data seem balanced?</p>
</div>
<div class="section" id="Exercise-3">
<h3>Exercise 3<a class="headerlink" href="#Exercise-3" title="Permalink to this headline">¶</a></h3>
<p>One of the other advantages of matching is that even when you have balanced data, you don’t have to go through the process of testing out different functional forms to see what fits the data base.</p>
<p>In our last exercise, we looked at the relationship between gender and earnings “controlling for age”, where we just put in age as a linear control. Plot a non-linear regression of annual_earnings on age (if you’re using <code class="docutils literal notranslate"><span class="pre">plotnine</span></code>, use <code class="docutils literal notranslate"><span class="pre">geom_smooth(method=&quot;lowess&quot;)</span></code>.</p>
<p>Does the relationship look linear?</p>
<p>Does this speak to why it’s nice to not have to think about functional forms with matching as much?</p>
</div>
</div>
<div class="section" id="Matching!">
<h2>Matching!<a class="headerlink" href="#Matching!" title="Permalink to this headline">¶</a></h2>
<p>Because DAME is an implementation of exact matching, we have to discretize all of our continuous variables. Thankfully, in this case we only have <code class="docutils literal notranslate"><span class="pre">age</span></code>, so this shouldn’t be too hard!</p>
<div class="section" id="Exercise-4">
<h3>Exercise 4<a class="headerlink" href="#Exercise-4" title="Permalink to this headline">¶</a></h3>
<p>Create a new variable that discretizes age into a single value for each decade of age.</p>
<p>Because CPS only has employment data on people 18 or over, though, include people who are 18 or 19 with the 20 year olds so that group isn’t too small, and if you see any other really small groups, please merge those too.</p>
</div>
<div class="section" id="Exercise-5">
<h3>Exercise 5<a class="headerlink" href="#Exercise-5" title="Permalink to this headline">¶</a></h3>
<p>We also have to covert our string variables into numeric variables for DAME, so convert <code class="docutils literal notranslate"><span class="pre">county</span></code> and <code class="docutils literal notranslate"><span class="pre">class94</span></code> to a numeric vector of intergers.</p>
<p>(Note: it’s not clear whether <code class="docutils literal notranslate"><span class="pre">class94</span></code> belongs: if it reflects people choosing fields based on passion, it belongs; if people choose certain jobs because of their degrees, its not something we’d actually want in our regression.</p>
<p>Hint: if you use <code class="docutils literal notranslate"><span class="pre">pd.Categorical</span></code> to convert you var to a categorical, you can pull the underlying integer codes with <code class="docutils literal notranslate"><span class="pre">.codes</span></code>.</p>
</div>
</div>
<div class="section" id="Let’s-Do-Matching-with-DAME">
<h2>Let’s Do Matching with DAME<a class="headerlink" href="#Let’s-Do-Matching-with-DAME" title="Permalink to this headline">¶</a></h2>
<div class="section" id="Exercise-6">
<h3>Exercise 6<a class="headerlink" href="#Exercise-6" title="Permalink to this headline">¶</a></h3>
<p>First, drop all the variables you <em>don’t</em> want in matching (e.g. your original <code class="docutils literal notranslate"><span class="pre">age</span></code> variable), and any observations for which <code class="docutils literal notranslate"><span class="pre">annual_earnings</span></code> is missing.</p>
<p>You will probably also have to drop a column named <code class="docutils literal notranslate"><span class="pre">index</span></code>: DAME will try and match on ANY included variables, and so because there was a column called <code class="docutils literal notranslate"><span class="pre">index</span></code> in the data we imported, if we leave it in DAME will try (and obviously fail) to match on index.</p>
<p>Also, it’s best to reset your index, as <code class="docutils literal notranslate"><span class="pre">dame_flame</span></code> using index labels to identify matches.</p>
</div>
<div class="section" id="Exercise-7">
<h3>Exercise 7<a class="headerlink" href="#Exercise-7" title="Permalink to this headline">¶</a></h3>
<p>The syntax of <code class="docutils literal notranslate"><span class="pre">dame_flame</span></code> is similar to the syntax of <code class="docutils literal notranslate"><span class="pre">sklearn</span></code>. If you start with a dataset called <code class="docutils literal notranslate"><span class="pre">my_data</span></code> with a <code class="docutils literal notranslate"><span class="pre">treat</span></code> variable with treatment assignment and an <code class="docutils literal notranslate"><span class="pre">outcome</span></code> variable for my outcome of interest (<span class="math notranslate nohighlight">\(Y\)</span>), the syntax to do basic matching would be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dame_flame</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">dame_flame</span><span class="o">.</span><span class="n">matching</span><span class="o">.</span><span class="n">DAME</span><span class="p">(</span><span class="n">repeats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">want_pe</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
    <span class="n">my_data</span><span class="p">,</span>
    <span class="n">treatment_column_name</span><span class="o">=</span><span class="s2">&quot;treat&quot;</span><span class="p">,</span>
    <span class="n">outcome_column_name</span><span class="o">=</span><span class="s2">&quot;outcome&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">my_data</span><span class="p">)</span>
</pre></div>
</div>
<p>Where the arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">repeats=False</span></code> says that I want to do 1:1 matching (each observation is only paired once). We’ll talke about what happens if we use <code class="docutils literal notranslate"><span class="pre">repeats=True</span></code> below.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose=3</span></code> tells dame to report everything it’s doing as it goes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">want_pe</span></code> says “please include the predictive error in your printout at each step”. This is a measure of match quality.</p></li>
</ul>
<p>So run DAME on your data!</p>
</div>
</div>
<div class="section" id="Interpreting-DAME-output">
<h2>Interpreting DAME output<a class="headerlink" href="#Interpreting-DAME-output" title="Permalink to this headline">¶</a></h2>
<p>The output you get from doing this <em>should</em> be reports from about 8 iterations of matching. In each iteration, you’ll see a description of the number of matches made in the interation, the number of treatment units still unmatched, and the number of control units unmatched.</p>
<p>In the first iteration, the algorithm tries to match observations that match on <em>all</em> the variables in your data. That’s why in the first iteration, you see the set of variables being drop is an empty set – it <em>hasn’t</em> dropped any variables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Iteration</span> <span class="n">number</span><span class="p">:</span>  <span class="mi">1</span>
    <span class="n">Number</span> <span class="n">of</span> <span class="n">matched</span> <span class="n">groups</span> <span class="n">formed</span> <span class="ow">in</span> <span class="n">total</span><span class="p">:</span>  <span class="mi">370</span>
    <span class="n">Unmatched</span> <span class="n">treated</span> <span class="n">units</span><span class="p">:</span>  <span class="mi">644</span> <span class="n">out</span> <span class="n">of</span> <span class="n">a</span> <span class="n">total</span> <span class="n">of</span>  <span class="mi">1150</span> <span class="n">treated</span> <span class="n">units</span>
    <span class="n">Unmatched</span> <span class="n">control</span> <span class="n">units</span><span class="p">:</span>  <span class="mi">3187</span> <span class="n">out</span> <span class="n">of</span> <span class="n">a</span> <span class="n">total</span> <span class="n">of</span>  <span class="mi">4365</span> <span class="n">control</span> <span class="n">units</span>
    <span class="n">Predictive</span> <span class="n">error</span> <span class="n">of</span> <span class="n">covariates</span> <span class="n">chosen</span> <span class="n">this</span> <span class="n">iteration</span><span class="p">:</span>  <span class="mi">0</span>
    <span class="n">Number</span> <span class="n">of</span> <span class="n">matches</span> <span class="n">made</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">iteration</span><span class="p">:</span>  <span class="mi">1684</span>
    <span class="n">Number</span> <span class="n">of</span> <span class="n">matches</span> <span class="n">made</span> <span class="n">so</span> <span class="n">far</span><span class="p">:</span>  <span class="mi">1684</span>
    <span class="n">In</span> <span class="n">this</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">the</span> <span class="n">covariates</span> <span class="n">dropped</span> <span class="n">are</span><span class="p">:</span>  <span class="nb">set</span><span class="p">()</span>
</pre></div>
</div>
<p>But as we can see from this output, the algorithm found 1,684 perfect matches – pairs of observations (one treated, one untreated) that had <em>exactly</em> the same value of all the variables we included. But we also see we still have 644 unmatched treated units, so what do we do? The answer is that we have to drop some of our matching variables and try again. But what variable should we drop?</p>
<p>This is the secret sauce of DAME. DAME picks the variables to drop by trying to predict our outcome <span class="math notranslate nohighlight">\(Y\)</span> using all our variables (by default using a ridge regression), then it drops the matching variable that is contributing the least to that prediction. Since our goal in matching is to eliminate baseline differences (<span class="math notranslate nohighlight">\(E(Y_0|D=1) - E(Y_1|D=0)\)</span>), dropping the covariates least related to <span class="math notranslate nohighlight">\(Y\)</span> makes sense.</p>
<p>As a result, in the second iteration, we see that the variable it drops first is <code class="docutils literal notranslate"><span class="pre">county</span></code>, and it’s subsequently able to make another 3,626 new matches on the remaining variables!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Iteration</span> <span class="n">number</span><span class="p">:</span>  <span class="mi">2</span>
    <span class="n">Number</span> <span class="n">of</span> <span class="n">matched</span> <span class="n">groups</span> <span class="n">formed</span> <span class="ow">in</span> <span class="n">total</span><span class="p">:</span>  <span class="mi">494</span>
    <span class="n">Unmatched</span> <span class="n">treated</span> <span class="n">units</span><span class="p">:</span>  <span class="mi">25</span> <span class="n">out</span> <span class="n">of</span> <span class="n">a</span> <span class="n">total</span> <span class="n">of</span>  <span class="mi">1150</span> <span class="n">treated</span> <span class="n">units</span>
    <span class="n">Unmatched</span> <span class="n">control</span> <span class="n">units</span><span class="p">:</span>  <span class="mi">180</span> <span class="n">out</span> <span class="n">of</span> <span class="n">a</span> <span class="n">total</span> <span class="n">of</span>  <span class="mi">4365</span> <span class="n">control</span> <span class="n">units</span>
    <span class="n">Predictive</span> <span class="n">error</span> <span class="n">of</span> <span class="n">covariates</span> <span class="n">chosen</span> <span class="n">this</span> <span class="n">iteration</span><span class="p">:</span>  <span class="mf">1199421883.1095908</span>
    <span class="n">Number</span> <span class="n">of</span> <span class="n">matches</span> <span class="n">made</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">iteration</span><span class="p">:</span>  <span class="mi">3626</span>
    <span class="n">Number</span> <span class="n">of</span> <span class="n">matches</span> <span class="n">made</span> <span class="n">so</span> <span class="n">far</span><span class="p">:</span>  <span class="mi">5310</span>
    <span class="n">In</span> <span class="n">this</span> <span class="n">iteration</span><span class="p">,</span> <span class="n">the</span> <span class="n">covariates</span> <span class="n">dropped</span> <span class="n">are</span><span class="p">:</span>  <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;county&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>And so DAME continues until after 8 iterations, it’s matched all treated observations.</p>
<div class="section" id="Exercise-8">
<h3>Exercise 8<a class="headerlink" href="#Exercise-8" title="Permalink to this headline">¶</a></h3>
<p>Congratulations! You just on your first one-to-one matching!</p>
<p>The next step is to think about which of the matches that DAME generated are good enough for inclusion in our analysis. As you may recall, one of the choices you have to make as a researcher when doing matching is how “good” a match has to be in order to be included in your final data set. By default, DAME will keep dropping matching variables until it has been able to match all of the treated observations or runs out of variables. It will do this no matter how bad the matches start to become –
if it ends up with the treated observation and a control observation that can only be matched on gender, it will match them just on gender, even though we probably don’t think that that’s a “good” match.</p>
<p>The way to control this behavior is to tell DAME when to stop manually using the <code class="docutils literal notranslate"><span class="pre">early_stop_iterations</span></code> argument to tell the matching algorithm when to stop.</p>
<p>So when is a good time to stop? There’s no objective or “right” answer to that question. It fundamentally comes down to a trade-off between bias (which gets higher is you allow more low quality matches into your data) and variance (which will go down as you increase the number of matches you keep).</p>
<p>But one way to start the process of picking a cutpoint is to examine how the quality of matches evolves over iterations. DAME keep this information in <code class="docutils literal notranslate"><span class="pre">model.pe_each_iter</span></code>. This shows, for each iteration, the “prediction error” resulting from dropping the variables excluded in each step. This “prediction error” is the difference in the mean-squared error of regressing <span class="math notranslate nohighlight">\(Y\)</span> on our matching variables (by default in a ridge regression) with all variables versus with the subset being used for
matching in a given iteration. By design, of course, this is always increasing.</p>
<p>To see how this evolves, plot your <code class="docutils literal notranslate"><span class="pre">pe</span></code> against iteration numbers. Note that our first iteration doesn’t count, since by definition the first iteration has an error of 0, and also note that the iterations count from 1, not 0 (weird for Python… but whatever). You can also see the <code class="docutils literal notranslate"><span class="pre">pe</span></code> values for each iteration reported in the output from when DAME ran above if you want to make your you’re lining up the errors with iterations right.</p>
<p>Are there any points where the match quality seems to fall off dramatically?</p>
</div>
<div class="section" id="Exercise-9">
<h3>Exercise 9<a class="headerlink" href="#Exercise-9" title="Permalink to this headline">¶</a></h3>
<p>Suppose we want to ensure we have at least 5,000 observations in our data – where might you cut off the data to get a sample size of at least that but before a big quality falloff?</p>
</div>
<div class="section" id="Exercise-10">
<h3>Exercise 10<a class="headerlink" href="#Exercise-10" title="Permalink to this headline">¶</a></h3>
<p>Re-run your matching, stopping at the point you picked above using <code class="docutils literal notranslate"><span class="pre">early_stop_iterations</span></code>.</p>
</div>
</div>
<div class="section" id="Getting-Back-a-Dataset">
<h2>Getting Back a Dataset<a class="headerlink" href="#Getting-Back-a-Dataset" title="Permalink to this headline">¶</a></h2>
<p>OK, my one current complaint with DAME is that it doesn’t just give you back a nice dataset of your matches for analysis. If we look at our results – <code class="docutils literal notranslate"><span class="pre">matches</span></code> – it’s <em>almost</em> what we want, except it’s dropped our treatment and outcome columns, and it’s put a string <code class="docutils literal notranslate"><span class="pre">*</span></code> in any entry where a value <em>wasn’t</em> used for matching:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">female</span> <span class="n">simplified_race</span>   <span class="n">county</span>   <span class="n">class94</span>   <span class="n">discretized_age</span>
<span class="mi">0</span>  <span class="mf">1.0</span>     <span class="mf">0.0</span>              <span class="mf">10.0</span>      <span class="mf">3.0</span>          <span class="mf">5.0</span>
<span class="mi">1</span>  <span class="mf">0.0</span>     <span class="mf">2.0</span>              <span class="o">*</span>         <span class="mf">3.0</span>          <span class="mf">3.0</span>
<span class="mi">2</span>  <span class="mf">0.0</span>     <span class="mf">0.0</span>              <span class="mf">8.0</span>        <span class="mf">3.0</span>         <span class="mf">6.0</span>
<span class="mi">3</span>  <span class="mf">0.0</span>     <span class="mf">0.0</span>              <span class="o">*</span>         <span class="mf">1.0</span>          <span class="mf">4.0</span>
<span class="mi">4</span>  <span class="mf">0.0</span>     <span class="mf">0.0</span>              <span class="mf">24.0</span>      <span class="mf">3.0</span>          <span class="mf">3.0</span>
</pre></div>
</div>
<p>So for now (though I think this will get updated in the package), we’ll have to do it ourselves! Just copy-paste this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_dataframe</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">result_of_fit</span><span class="p">):</span>

    <span class="n">better</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">input_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">result_of_fit</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
    <span class="n">better</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">model</span><span class="o">.</span><span class="n">groups_per_unit</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">repeats</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">better</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

    <span class="c1"># Make sure right N!</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_of_fit</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">better</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">better</span>
</pre></div>
</div>
<div class="section" id="Exercise-11">
<h3>Exercise 11<a class="headerlink" href="#Exercise-11" title="Permalink to this headline">¶</a></h3>
<p>Copy-paste that code and run it with your original data, your (fit) model, and what you got back when you ran <code class="docutils literal notranslate"><span class="pre">result_of_fit</span></code>. Then we’ll work with the output of that. You should get back a single dataframe of the same length as your original model. Note you’ll see a bunch of “Unit X does not have any matches” warnings – ignore those!</p>
</div>
</div>
<div class="section" id="Check-Your-Matches-and-Analyze">
<h2>Check Your Matches and Analyze<a class="headerlink" href="#Check-Your-Matches-and-Analyze" title="Permalink to this headline">¶</a></h2>
<div class="section" id="Exercise-12">
<h3>Exercise 12<a class="headerlink" href="#Exercise-12" title="Permalink to this headline">¶</a></h3>
<p>We previously tested balance on <code class="docutils literal notranslate"><span class="pre">simplified_race</span></code>, and by county. Check those again. Are there still statistically significant differences in college education by <code class="docutils literal notranslate"><span class="pre">simplified_race</span></code>?</p>
</div>
<div class="section" id="Exercise-13">
<h3>Exercise 13<a class="headerlink" href="#Exercise-13" title="Permalink to this headline">¶</a></h3>
<p>OK, it’s finally time to run some analyses! As we discussed, for this kind of 1:1 matching, we can just stick this matched dataset into a regression to analyze it.</p>
<p>Use a linear regression on your matched data to regress annual earnings on <em>just</em> having a college eduction. What is the apparent effect of earnings? How does that compare to our initial estimate using the raw CPS data (before matching)?</p>
</div>
<div class="section" id="Exercise-14">
<h3>Exercise 14<a class="headerlink" href="#Exercise-14" title="Permalink to this headline">¶</a></h3>
<p>Now include our other matching variables as controls. Does the coefficient change?</p>
</div>
<div class="section" id="Exercise-15">
<h3>Exercise 15<a class="headerlink" href="#Exercise-15" title="Permalink to this headline">¶</a></h3>
<p>If you stopped matching after Iteration 2 back in Exercise XXX, you may be finding that (a) there are still some imbalances by race, and (b) the results of your estimate are about the same with matching as they were initially!</p>
<p>This likely means one of two things:</p>
<ol class="arabic simple">
<li><p>The returns to a college education really just don’t vary across people, and so the raw average difference is a pretty good guess for the ATT.</p></li>
<li><p>Our matching was a little sloppy (implied by the statistically significant racial differences we found in our matched data).</p></li>
</ol>
<p>So to test for number 2, let’s go back and stop DAME after the first iteration instead of the second.</p>
<p>Then re-check balance and your estimate of the effects of a college education. What do you see?</p>
</div>
<div class="section" id="Exercise-16">
<h3>Exercise 16<a class="headerlink" href="#Exercise-16" title="Permalink to this headline">¶</a></h3>
<p>Use a linear regression on your matched data to regress annual earnings on <em>just</em> having a college eduction. What is the apparent effect of earnings? How does that compare to our initial estimate using the raw CPS data (before matching)?</p>
</div>
<div class="section" id="Exercise-17">
<h3>Exercise 17<a class="headerlink" href="#Exercise-17" title="Permalink to this headline">¶</a></h3>
<p>Now include our other matching variables as controls. Does the coefficient change?</p>
</div>
</div>
<div class="section" id="Other-Forms-of-Matching">
<h2>Other Forms of Matching<a class="headerlink" href="#Other-Forms-of-Matching" title="Permalink to this headline">¶</a></h2>
<p>OK, hopefully this gives you a taste of matching! There are, of course, <em>many</em> other permutations to be aware of though.</p>
<ul class="simple">
<li><p>Many-to-1 matching: In this exercise, we set <code class="docutils literal notranslate"><span class="pre">repeat=False</span></code>, so each observation could only end up in our final dataset once. However, if we use <code class="docutils literal notranslate"><span class="pre">repeat=True</span></code>, if an untreated observation is the closest observation to multiple treated observations, it may get put in the dataset multiple times. We can still use this dataset in <em>almost</em> the same way, though, except we have to make use of weights so that if an observation appears, say, twice, each observation has a weight that’s 1/2 the
weight of an observation only appearing once.</p></li>
<li><p>Matching with continuous variables: DAME is used for exact matching, but if you have lots of continuous variables, you can also match on those. In fact, the Almost Exact Matching Lab also has a library called <a class="reference external" href="https://almost-matching-exactly.github.io/MALTS/">MALTS</a> that will do matching with continuous variables. That package does something <em>like</em> Mahalanobis Distance matching, but ulike Mahalanobis, which calculates the distance between observations in terms of the difference in all the
matching variables normalized by each matching variable’s standard deviation, MALTS does something much more clever. (Here’s <a class="reference external" href="https://arxiv.org/abs/1811.07415">the paper</a> describing the technique if you want all the details). Basically, it figures out how well each matching variable predicts our outcome <span class="math notranslate nohighlight">\(Y\)</span>, then weights the different variables by their predictive power instead of just normalizing by something arbitrary like their standard deviation. As a result, final matches will
prioritize matching more closely on variables that are outcome-relevant. In addition, when it sees a categorical variable, it recognizes that and only pairs observations when they are an exact match on that categorical variable.</p></li>
<li><p>If you’re dataset is huge, use <code class="docutils literal notranslate"><span class="pre">FLAME</span></code>: this dataset is small, but if you have lots of observations and lots of matching variable, the computational complexity of this task explodes, so the AEML created FLAME, which works with millions of observations at only a small cost to match quality.</p></li>
</ul>
</div>
<div class="section" id="Absolutely-positively-need-the-solutions?">
<h2>Absolutely positively need the solutions?<a class="headerlink" href="#Absolutely-positively-need-the-solutions?" title="Permalink to this headline">¶</a></h2>
<p><em>Don’t use this link until you’ve really, really spent time struggling with your code!</em> Doing so only results in you cheating yourself.</p>
<p><a class="reference internal" href="../solutions_warning.html"><span class="doc">Link</span></a></p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Unifying DS</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../class_schedule.html">CLASS SCHEDULE</a></li>
</ul>
<p class="caption"><span class="caption-text">QUESTIONS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../taxonomy_of_questions.html">Taxonomy of Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../moving_from_problems_to_questions.html">From Problems to Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../descriptive_questions.html">Discretion and Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../limitations_of_ATE.html">Limitations of Experiments</a></li>
</ul>
<p class="caption"><span class="caption-text">METHODS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../interpreting_indicator_vars.html">Indicator Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fixed_effects.html">Fixed Effects</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Nick Eubank.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/exercises/exercise_matching.ipynb.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-151397036-1']);
      _gaq.push(['_setDomainName', 'none']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    
  </body>
</html>